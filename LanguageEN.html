<html>
	<head>
		<title>NULLC Language reference</title>
<style type="text/css">
p.code
{
	background: #eee;
	font-family: Consolas, Courier New, monospace;
	font-size: 10pt;
}
span.rword
{
	color: #00f;
}
span.func
{
	color: #880000;
	font-style: italic;
}
span.var
{
	color: #555;
}
span.real 
{
	color: #008800;
}
span.comment
{
	color: #f0f;
}
span.string
{
	color: #880000;
}
div.topic
{
	margin-left: 20px;
}
div.subtopic
{
	margin-left: 20px;
}
p.example_head
{
	font-weight: bold;
	cursor: pointer;
	background-color: #dfd;
}
p.example_body
{
	display: none;
	margin-left: 10px;
}
div.example
{
}
</style>
<script language="javascript" type="text/javascript">
var hashMap = new Array();
function toggleView(a, b, c)
{
	if(hashMap[a] == undefined)
		hashMap[a] = 1;
	else
		hashMap[a] = 1 - hashMap[a];
	document.getElementById(b).style.display = hashMap[a] ? "block" : "none";
	document.getElementById(a).innerHTML = (hashMap[a] ? "Hide " : "Show ") + c;
}
</script>
	</head>
	<body>
<h2 align="center">NULLC Language reference</h2>
<ol>
	<li>General</li>
	<ol>
		<li><a href="#basictypes">Basic types</a></li>
		<li><a href="#varalign">Variable alignment</a></li>
		<li><a href="#typeauto">Type inference</a></li>
	</ol>
	<li>Expressions</li>
	<ol>
		<li><a href="#import">import expression</a></li>
		<li><a href="#typeof">typeof expression</a></li>
		<li><a href="#sizeof">sizeof expression</a></li>
		<li><a href="#new">new expression</a></li>
		<ol>
			<li><a href="#gc">Garbage collection</a></li>
		</ol>
		<li><a href="#break">break expression</a></li>
		<li><a href="#continue">continue expression</a></li>
		<li><a href="#return">return expression</a></li>
		<li><a href="#typedef">typedef expression</a></li>
	</ol>
	<li>Statements</li>
	<ol>
		<li><a href="#if">if statement</a></li>
		<li><a href="#for">for statement</a></li>
		<ol>
			<li><a href="#forsimple">C-style for</a></li>
			<li><a href="#foreach">for each</a></li>
			<li><a href="#foreachiternator">Custom iterator</a></li>
		</ol>
		<li><a href="#while">while statement</a></li>
		<li><a href="#do">do...while statement</a></li>
		<li><a href="#switch">switch statement</a></li>
	</ol>
	<li>Declarations</li>
	<ol>
		<li><a href="#classes">User classes</a></li>
		<ol>
			<li><a href="#classaccessor">Accessors</a></li>
		</ol>
		<li><a href="#vardef">Variables</a></li>
		<li><a href="#functions">Functions</a></li>
		<ol>
			<li><a href="#varargs">Variable argument list</a></li>
			<li><a href="#funclocal">Local functions</a></li>
			<li><a href="#funcclosure">Closures</a></li>
			<li><a href="#funcmember">Member functions</a></li>
			<li><a href="#funcinline">Function Literals</a></li>
			<li><a href="#funcoverload">Function overloading</a></li>
			<li><a href="#funcoperators">Operator overloading</a></li>
		</ol>
		<li><a href="#arrunsized">Arrays with implicit size</a></li>
	</ol>
	<li>Special types</li>
	<ol>
		<li><a href="#autoref">auto ref</a></li>
		<ol>
			<li><a href="#auterefcast">explicit conversion</a></li>
			<li><a href="#autorefcall">function call through auto ref</a></li>
		</ol>
		<li><a href="#typeid">typeid</a></li>
	</ol>
	<li>Miscellaneous</li>
	<ol>
		<li><a href="#characters">Characters</a></li>
		<li><a href="#strings">Strings</a></li>
		<li><a href="#arrayinline">Inline arrays</a></li>
		<li><a href="#escapeseq">Escape sequences</a></li>
		<li><a href="#binnum">Binary numbers</a></li>
		<li><a href="#octnum">Octal numbers</a></li>
		<li><a href="#hexnum">Hexadecimal numbers</a></li>
	</ol>
	<li>Standard library</li>
	<ol>
		<li><a href="#std_typeinfo">std.typeinfo</a></li>
		<li><a href="#std_dynamic">std.dynamic</a></li>
		<li><a href="#std_gc">std.gc</a></li>
		<li><a href="#std_vector">std.vector</a></li>
		<li><a href="#std_list">std.list</a></li>
		<li><a href="#std_range">std.range</a></li>
		<li><a href="#std_file">std.file</a></li>
		<li><a href="#std_io">std.io</a></li>
		<li><a href="#std_random">std.random</a></li>
		<li><a href="#std_time">std.time</a></li>
	</ol>
	<li>Appendix</li>
	<ol>
		<li><a href="#convrules">Rules applied to value types in a binary operation</a></li>
		<li><a href="#oppriority">Operator priority</a></li>
		<li><a href="#convimplicit">Implicit conversions</a></li>
	</ol>
</ol>
<hr />
<h2 align="center">1. General</h2>
<div class="topic">
	<h3><a name="basictypes">1.1 Basic types</a></h3>

	<table border="1px">
		<tr><th>Name</th><th>Size</th><th>Default alignment</th><th>Extra information</th></tr>
		<tr><td>void</td><td>0 bytes</td><td>no alignment</td><td>only allowed as a function return value (returns nothing)</td></tr>
		<tr><td>char</td><td>1 byte</td><td>no alignment</td><td>values: 0..255</td></tr>
		<tr><td>short</td><td>2 bytes</td><td>no alignment</td><td>values: -32768..32767</td></tr>
		<tr><td>int</td><td>4 bytes</td><td>4 bytes</td><td>values: -2147483648..2147483647</td></tr>
		<tr><td>long</td><td>8 bytes</td><td>no alignment</td><td>values: -9223372036854775808..9223372036854775807</td></tr>
		<tr><td>float</td><td>4 bytes</td><td>4 bytes</td><td>values: as per IEEE 754</td></tr>
		<tr><td>double</td><td>8 bytes</td><td>8 bytes</td><td>values: as per IEEE 754</td></tr>
	</table>
</div>
<hr />
<div class="topic">
	<h3><a name="varalign">1.2 Variable alignment</a></h3>

	Default type alignment can be changed using two statements:<br />
	noalign before type name will disable any default type alignment:<br />
	<p class="code">
		<span class="rword">noalign</span> <span class="rword">type</span> name; <span class="comment">// variable "name" of type "type" will not be aligned</span>
	</p>
	align(bytes) before type name will force specified alignment:<br />
	<p class="code">
		<span class="rword">align</span>(<span class="real">8</span>) <span class="rword">type</span> name; <span class="comment">// variable "name" of type "type" will be aligned to a 8 byte boundary.</span>
	</p>
	Alignment must not exceed 16 bytes.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="typeauto">1.3 Type inference</a></h3>

	When defining a variable, type name can be replaced with a keyword "auto".<br />
	In this case, type will be inferred from r-value type.<br />
	Here are some examples:
	<p class="code">
		<span class="rword">auto</span> i = <span class="real">5</span>; <span class="comment">// i will have type int</span><br />
		<span class="rword">auto</span> n = &i; <span class="comment">// n will have type int ref</span><br />
		<span class="rword">int</span>[<span class="real">10</span>] arr;<br />
		<span class="rword">auto</span> copy = arr; <span class="comment">// copy will have type int[10]</span>
	</p>
	Alignment of automatic types works just like with explicitly specified types.<br />
	<br />
	auto can be used as a function return type. If a function has different exit points returning different type, an error occurs.<br />
	auto can be used as a function argument type as long as this arguments has a default value.<br />
</div>
<hr />
<h2 align="center">2. Expressions</h2>
<div class="topic">
	<h3><a name="import">2.1 import expression</a></h3>

	<span class="rword">import</span> expressions allows code to import functions, classes and variables from other files.<br />
	<br />
	<span class="rword">import</span> expressions must be placed at the beginning of a file before any other expression or definition.<br />
	A file name without extension must be specified after <span class="rword">import</span>.<br />
	Also, folder name is accepted after <span class="rword">import</span> keyword, then a point '.' and another folder\file name expected.<br />
	<br />
	Expression examples:<br />
	<p class="code">
		<span class="rword">import</span> a; <span class="comment">// builds a.nc file and imports functions, classes and variables from it</span><br />
		<span class="rword">import</span> d.e; <span class="comment">// builds d\e.nc file and imports functions, classes and variables from it</span><br />
	</p>
</div>
<hr />
<div class="topic">
	<h3><a name="typeof">2.2 typeof operator</a></h3>

	<span class="rword">typeof</span>(expression) allows to get type of an expression (expression will not be evaluated at run time).<br />
	<br />
	<span class="rword">typeof</span>(<span class="real">4</span>) is equal to specifying int.<br />
	<span class="rword">typeof</span>(<span class="real">4</span> * <span class="real">0.2</span>) is equal to specifying double.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="sizeof">2.3 sizeof operator</a></h3>

	<span class="rword">sizeof</span>(type) returns size of type.<br />
	<span class="rword">sizeof</span>(expression) returns size of the expression type (it is equal to "<span class="rword">sizeof</span>(<span class="rword">typeof</span>(expression))")<br />
</div>
<hr />
<div class="topic">
	<h3><a name="new">2.4 new expression</a></h3>

	<span class="rword">new</span> expression allows to allocate memory from global heap.<br />
	There are two versions of this expression - one is used to allocate classes and the second one is used to allocate arrays.<br />
	<br />
	Return type of "<span class="rword">new</span> type" is 'type ref'.<br />
	Return type of "<span class="rword">new</span> type[N]", where N is an expression that results in a number is 'type[]'.<br />
	<div class="subtopic">
		<h3><a name="gc">2.4.1 Garbage collection</a></h3>

		There is not implicit memory deallocation function, dynamic memory is managed by NULLC and is garbage collected.<br />
		Garbage collection is aware that some pointers may point to a memory not managed by NULLC (you can pass pointers to your objects safely to NULLC) and will skip those.<br />
		<br />
		Some form of explicit management is exposed throught <a href="#std_gc" title="std.gc module">std.gc</a> module.<br />
	</div>
</div>
<hr />
<div class="topic">
	<h3><a name="break">2.5 break expression</a></h3>

	<span class="rword">break</span> expression allows to end execution of a cycle.<br />
	<br />
	<span class="rword">break</span>; exits current cycle.<br />
	<span class="rword">break</span> <span class="real">N</span>; where N is number, known at compile time exits from N cycles beginning from where it is written.<br />
	<span class="rword">break</span> <span class="real">1</span>; is equal to <span class="rword">break</span>;<br />
</div>
<hr />
<div class="topic">
	<h3><a name="continue">2.6 continue expression</a></h3>

	<span class="rword">continue</span> expression allows to skip to the next iteration of a cycle.<br />
	<br />
	<span class="rword">continue</span>; skips to the end of current cycle.<br />
	<span class="rword">continue</span> <span class="real">N</span>; where N is number, known at compile time exits from (N-1) cycles beginning from where it is written and skips to the next iteration of cycle it ends up.<br />
	<span class="rword">continue</span> <span class="real">1</span>; is equal to <span class="rword">continue</span>;<br />
</div>
<hr />
<div class="topic">
	<h3><a name="return">2.7 return expression</a></h3>

	<span class="rword">return</span> expression allows to return a value or exit from a function, or to end execution of a program if placed in global scope.<br />
	<br />
	<span class="rword">return</span>; exits function, returning void type (nothing).<br />
	<span class="rword">return</span> expr; exits function or ends program execution, returning result of "expr".<br />
	<br />
	<span class="rword">return</span> that is placed globally accepts only basic build-un types and cannot return void.<br />
	When returning value from function, it is converted to functions return type if conversion is possible.<br />
	If function return type is <a href="#typeauto">auto</a>, function return type is set to the type of "expr".<br />
</div>
<hr />
<div class="topic">
	<h3><a name="typedef">2.8 typedef expression</a></h3>

	<span class="rword">typedef</span> expression allows to create one-word aliases to other types.<br />
	<br />
	<span class="rword">typedef</span> doesn't create new type, it just allows its target type to have different names.<br />
	<br />
	Examples:
	<p class="code">
		<span class="rword">typedef</span> <span class="rword">int</span>[<span class="real">4</span>] fourInts;<br />
		<span class="rword">typedef</span> <span class="rword">int</span> <span class="rword">ref</span>(<span class="rword">int</span>, <span class="rword">int</span>) drawCallback;<br />
	</p>
</div>
<hr />

<h2 align="center">3. Statements</h2>
<div class="topic">
	<h3><a name="if">3.1 if statement</a></h3>

	<p class="code">
		<span class="rword">if</span>(<span class="var">expr</span>)<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">trueBody</span><br />
		<span class="rword">else</span><br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">falseBody</span><br />
	</p>
	<span class="rword">if</span> statement evaluates result of expression "expr", and if result isn't equal to 0, evaluates expressions put in "trueBody". Otherwise, it evaluates expressions put in "falseBody".<br />
	"trueBody" and "falseBody" may consist of a single expression or a block of expressions.<br />
	<span class="rword">else</span> and "falseBody", may be omitted. In such case, if result of "expr" is zero, nothing is evaluated.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="for">3.2 for statement</a></h3>

	<div class="subtopic">
		<h4><a name="forsimple">3.2.1 C-style for</a></h4>

		<p class="code">
			<span class="rword">for</span>(<span class="var">initexpr</span>; <span class="var">condexpr</span>; <span class="var">iterexpr</span>)<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">body</span><br />
		</p>
		<span class="rword">for</span> statement is a cycle that evaluates "initexpr", and executes "body" while "condexpr" evaluates to a non-zero value.<br />
		"iterexpr" is evaluated at the end of every cycle.<br />
		<br />
		"body", "initexpr" and "iterexpr" may consist of a single expression or a block of expressions.<br />
		"condexpr" must be a single expression with result type of int\long\double.<br />
	</div>
	<div class="subtopic">
		<h4><a name="foreach">3.2.2 for each</a></h4>

		A shorter form of for exists to iterate through all elements of an array or a custom iterator.<br />
		<p class="code">
			<span class="rword">for</span>(<span class="rword">type</span> <span class="var">refName</span> <span class="rword">in</span> <span class="var">expression</span>, <span class="rword">type</span> <span class="var">refNameN</span> <span class="rword">in</span> <span class="var">expressionN</span>)<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">body</span><br />
		</p>
		<span class="rword">type</span> name is optional and should be used when iterator return type is <a href="#autoref" title="auto ref type"><span class="rword">auto ref</span></a>, to convert it to selected type.<br />
		If more that one iterator is specified, loop will terminate when one of the iterators reaches its end.<br />
		For example, return value of the folowing code is 14 (1 * 4 + 2 * 5):
		<p class="code"><span class="rword">int</span> sum = 0;<br />
			<span class="rword">for</span>(x <span class="rword">in</span> {1, 2, 3}, y <span class="rword">in</span> {4, 5})<br />
			&nbsp;&nbsp;&nbsp;&nbsp;sum += x * y;<br />
			<span class="rword">return</span> sum;<br />
		</p>
	</div>
	<div class="subtopic">
		<h4><a name="foreachiternator">3.2.3 Custom iterator</a></h4>

		If you wish to iterate over elements of your type or add a contextless custom iterator (for examples of those, see <a href="#std_range" title="std.range module">std.range</a> module), you must add a specific function:<br />
		<p class="code">
			<span class="rword">type_iterator</span> <span class="rword">type</span>:start()<br />
			{<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* code that returns iterator */</span><br />
			}
		</p>
		start() function will be explicitly called for expression to the right of <span class="rword">in</span> keyword.<br />
		<br />
		Iterator type must implement two functions:<br />
		<p class="code">
			<span class="rword">auto</span> <span class="rword">type_iterator</span>:hasnext()<br />
			{<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* return 1 if there are elements left to iterate through, and 0 to end iteration */</span><br />
			}
		</p>
		<p class="code">
			<span class="rword">auto</span> <span class="rword">type_iterator</span>:next()<br />
			{<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/* code that returns current element and moves on to the next */</span><br />
			}
		</p>
		Keep in mind that next() function should return <b>current</b> iterator element and move on to the next.<br />
		<div>
			<p class="example_head" id="iterator_ex_1a" onmousedown="toggleView(&quot;iterator_ex_1a&quot;, &quot;iterator_ex_1b&quot, &quot;example of an iterator over elements of a single-linked list.&quot;);">Show example of an iterator over elements of a single-linked list.</p>
			<p class="code example_body" id="iterator_ex_1b">
<span class="comment">// List node class containts element value and a pointer to the next element</span><br />
<span class="rword">class</span> <span class="rword">list_node</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">list_node</span> <span class="rword">ref</span>	next;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">int</span>				value;<br />
}<br />
<span class="comment">// list type iterator will contain pointer to the current node he is at.</span><br />
<span class="rword">class</span> <span class="rword">list_iterator</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">list_node</span> <span class="rword">ref</span> curr;<br />
}<br />
<span class="comment">// Iterator initialization function</span><br />
<span class="rword">auto</span> <span class="rword">list_node</span>:<span class="func">start</span>()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Create iterator</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">list_iterator</span> ret;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Set its start to this node</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">ret</span>.<span class="var">curr</span> = <span class="var">this</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// return iterator</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">ret</span>;<br />
}<br />
<span class="rword">auto</span> <span class="rword">list_iterator</span>:<span class="func">hasnext</span>()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// While curent node pointer is valid, signal that there are elements left to iterate through</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">curr</span> ? <span class="real">1</span> : <span class="real">0</span>;<br />
}<br />
<span class="comment">// This function will return iterator element and move on to the next</span><br />
<span class="rword">auto</span> <span class="rword">list_iterator</span>:<span class="func">next</span>()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Save element value</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">int</span> ret = <span class="var">curr</span>.<span class="var">value</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Move to the next element</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">curr</span> = <span class="var">curr</span>.<span class="var">next</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Return old element value</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">ret</span>;<br />
}<br />
<span class="comment">// Create a list of two numbers</span><br />
<span class="rword">list_node</span> list;<br />
<span class="var">list</span>.<span class="var">value</span> = <span class="real">2</span>;<br />
<span class="var">list</span>.<span class="var">next</span> = <span class="rword">new</span> <span class="rword">list_node</span>;<br />
<span class="var">list</span>.<span class="var">next</span>.<span class="var">value</span> = <span class="real">5</span>;<br />
<span class="comment">// Compute product of numbers in a list using our custom iterator</span><br />
<span class="rword">int</span> product = <span class="real">1</span>;<br />
<span class="rword">for</span>(i <span class="rword">in</span> <span class="var">list</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">product</span> *= <span class="var">i</span>;<br />
<span class="rword">return</span> <span class="var">product</span>;<br />
			</p>
		</div>
	</div>
</div>
<hr />
<div class="topic">
	<h3><a name="while">3.3 while statement</a></h3>

	<p class="code">
		<span class="rword">while</span>(<span class="var">condexpr</span>)<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">body</span><br />
	</p>
	<span class="rword">while</span> statement is a cycle that executes "body" while "condexpr" evaluates to a non-zero value.<br />
	<br />
	"body" may consist of a single expression or a block of expressions.<br />
	"condexpr" must be a single expression with result type of int\long\double.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="do">3.4 do...while statement</a></h3>

	<p class="code">
		<span class="rword">do</span><br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">body</span><br />
		<span class="rword">while</span>(<span class="var">condexpr</span>)<br />
	</p>
	<span class="rword">do</span> statement is a cycle that executes "body" while "condexpr" evaluates to a non-zero value.<br />
	Difference from while statement is that do statement evaluates body at least once, since condition is placed after the body.<br />
	<br />
	"body" may consist of a single expression or a block of expressions.<br />
	"condexpr" must be a single expression with result type of int\long\double.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="switch">3.5 switch statement</a></h3>

	<p class="code">
		<span class="rword">switch</span>(<span class="var">expr</span>)<br />
		{<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">case</span> <span class="real">A</span>:<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">caseBody</span>;<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">default</span>:<br />
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">defaultBody</span>;<br />
		}<br />
	</p>
	<span class="rword">switch</span> statement evaluates result of "expr" and compares result with case label values. If result matches <span class="rword">case</span> value, a jump to a matched <span class="rword">case</span> label is made and all expressions after it are evaluated.<br />
	If no case label value is equal to result, a jump to <span class="rword">default</span> label is made.<br />
	<span class="rword">break</span>; expression can be used inside <span class="rword">switch</span> statement.<br />
	<span class="rword">default</span> label can be omitted.<br />
	<span class="rword">switch</span> without case labels, or without any expressions at all is legal.<br />
</div>
<hr />

<h2 align="center">4. Declarations</h2>
<div class="topic">
	<h3><a name="classes">4.1 User classes</a></h3>

	<p class="code">
		<span class="rword">class</span> Name<br />
		{<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">type</span> name, name, ...;<br />
		&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">type</span> <span class="func">function</span>(<span class="rword">type</span> arg, <span class="rword">type</span> arg, ...){ }<br />
		&nbsp;&nbsp;&nbsp;&nbsp;...<br />
		}<br />
	</p>
	Class consists of variables, functions and typedefs' in any order, but keep in mind, functions can only access member variables that are defined before them.<br />
	<br />
	There is no default alignment by default. To specify alignment, put "noalign" of "align(bytes)" before "class" keyword.<br />
	Specifying "noalign" is superfluous. Alignment must not exceed 16 bytes.<br />
	<div class="subtopic">
		<h4><a name="classaccessor">4.1.1 Accessors</a></h4>

		There is a possibility to add virtual class members - members that can be used as any real class member, but access and modification of them is implemented in custom functions.<br />
		To add an accessor to your class, use the following syntax:<br />
		<p class="code">
			<span class="comment">// read-only accessor</span><br />
			<span class="rword">type</span> name{ <span class="rword">get</span>{ <span class="comment">/* getter body */</span> } };<br />
			<span class="comment">// accessor with read/write access</span><br />
			<span class="rword">type</span> name{ <span class="rword">get</span>{ <span class="comment">/* getter body */</span> } <span class="rword">set</span>{ <span class="comment">/* setter body */</span> } };<br />
			<span class="comment">// accessor with read-write access and a custom name for right-hand value of set function</span><br />
			<span class="rword">type</span> name{ <span class="rword">get</span>{ <span class="comment">/* getter body */</span> } <span class="rword">set</span>(value){ <span class="comment">/* setter body */</span> } };<br />
		</p>
		<div class="example">
			<p class="example_head" id="accessor_ex_1a" onmousedown="toggleView(&quot;accessor_ex_1a&quot;, &quot;accessor_ex_1b&quot, &quot;example of a read-only accessor.&quot;);">Show example of a read-only accessor.</p>
			<p class="code example_body" id="accessor_ex_1b">
<span class="comment">// Let's create a "sum" accessor to a class consisting of two numbers</span><br />
<span class="rword">class</span> <span class="rword">NumberPair</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">int</span> a, b;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// accessor is read-only and returns sum of both members. return type can be inferred automatically</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">auto</span> sum{ <span class="rword">get</span>{ <span class="rword">return</span> <span class="var">a</span> + <span class="var">b</span>; } };<br />
}<br />
<span class="rword">NumberPair</span> foo;<br />
<span class="var">foo</span>.<span class="var">a</span> = <span class="real">5</span>;<br />
<span class="var">foo</span>.<span class="var">b</span> = <span class="real">10</span>;<br />
<span class="rword">return</span> <span class="var">foo</span>.<span class="var">sum</span>;	<span class="comment">// returns 15</span><br />
			</p>
		</div>
		<div class="example">
			<p class="example_head" id="accessor_ex_2a" onmousedown="toggleView(&quot;accessor_ex_2a&quot;, &quot;accessor_ex_2b&quot, &quot;example of a read-write accessor.&quot;);">Show example of a read-write accessor.</p>
			<p class="code example_body" id="accessor_ex_2b">
<span class="comment">// Suppose we have a two-component floating point vector and we want to add a possibility for swizzling</span><br />
<span class="rword">class</span> <span class="rword">vec2</span><br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">float</span> x, y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// xy swizzle is trivial</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">auto</span> xy<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">get</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">this</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">set</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">x</span> = <span class="var">r</span>.<span class="var">x</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">y</span> = <span class="var">r</span>.<span class="var">y</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// in yx swizzle, a temporary vector should be created</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">auto</span> yx<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">get</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">vec2</span> tmp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">tmp</span>.<span class="var">x</span> = <span class="var">y</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">tmp</span>.<span class="var">y</span> = <span class="var">x</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">tmp</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">set</span>(value)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">y</span> = <span class="var">value</span>.<span class="var">x</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">x</span> = <span class="var">value</span>.<span class="var">y</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
}<br />
<span class="rword">vec2</span> foo;<br />
<span class="var">foo</span>.<span class="var">x</span> = <span class="real">1.5</span>;<br />
<span class="var">foo</span>.<span class="var">y</span> = <span class="real">2.5</span>;<br />
<span class="rword">vec2</span> bar;<br />
<span class="var">bar</span>.<span class="var">yx</span> = <span class="var">foo</span>.<span class="var">xy</span>;<br />
<span class="rword">return</span> <span class="var">foo</span>.<span class="var">x</span> * <span class="var">bar</span>.<span class="var">y</span>; <span class="comment">// returns 2.25</span><br />
			</p>
		</div>
		It is possible to add accessors to a class outside of a class definition. In this case, getter and setter are defined separately.<br />
		A syntax is similar to external <a href="#funcmember">member function definition</a>, only '.' is used instead of ':':<br />
		<p class="code">
<span class="comment">// Second accessor of "read-write accessor" example above defined outside of a class</span><br />
<span class="rword">auto</span> <span class="rword">vec2</span>.<span class="func">yx</span>()<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">vec2</span> tmp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">tmp</span>.<span class="var">x</span> = <span class="var">y</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">tmp</span>.<span class="var">y</span> = <span class="var">x</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">tmp</span>;<br />
}<br />
<span class="rword">void</span> <span class="rword">vec2</span>.<span class="func">yx</span>(<span class="rword">vec2</span> <span class="rword">ref</span> value)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">y</span> = <span class="var">value</span>.<span class="var">x</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">x</span> = <span class="var">value</span>.<span class="var">y</span>;<br />
}<br />
		</p>
	</div>
</div>
<hr />

<div class="topic">
	<h3><a name="vardef">4.2 Variables</a></h3>

	Simple variable definition syntax is:
	<p class="code">
		<span class="rword">type</span> name;
	</p>
	Arrays are defined like this:
	<p class="code">
		<span class="rword">type</span>[<span class="real">N</span>] name;
	</p>
	or
	<p class="code">
		<span class="rword">type</span>[] name;
	</p>
	If array size is specified, it must be a number known at compile type.<br />
	Second declaration is described in section <a href="#arrunsized">"Arrays with implicit size"</a>.<br />
	<br />
	Pointers are defined by using "ref" keyword:
	<p class="code">
		<span class="rword">type</span> <span class="rword">ref</span> name;
	</p>
	Pointers to functions are defined by using "ref" keyword, followed by a list of function argument types in parenthesis:
	<p class="code">
		<span class="rword">type</span> <span class="rword">ref</span>(<span class="rword">type</span>, <span class="rword">type</span>) name;
	</p>
	More than one variable can be defined in one statement, by specifying variable names after a comma.<br />
	All variables defined in one statement have equal type.<br />
	Different type modificators can be mixed together to form types like, for example:
	<p class="code">
		<span class="rword">int</span>[<span class="real">4</span>][<span class="real">2</span>] name; <span class="comment">// array of 4 arrays of two integers</span><br />
		<span class="rword">int</span> <span class="rword">ref</span>(<span class="rword">int</span>, <span class="rword">int</span>)[<span class="real">4</span>] name; <span class="comment">// array of 4 pointers to functions, returning int</span>
	</p>
	A value can be assigned to a variable in place of its definition, by writing "= value" after its name.<br />
	If array element is assigned to a type, then it will be a default value of all array elements.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="functions">4.3 Functions</a></h3>

	Global functions, nested (local) functions, member functions and function literals are supported.<br />
	<br />
	Function definition starts with a function return type, followed by name and a list of arguments in parenthesis.<br />
	List of arguments starts with a type that is followed by one or more parameter names, separated by comma. After a comma, a different type can be selected as well.<br />
	Function body must be enclosed in { } block.<br />
	<p class="code">
		<span class="rword">type</span> <span class="func">name</span>(<span class="rword">type</span> a, b, <span class="rword">type</span> c, d){ }
	</p>
	Function return type can be any type expression including <span class="rword">auto</span>.<br />
	Function argument type can be auto only if it has default argument value.<br />
	Function default argument value is specified by writing "= value" directly after argument name:<br />
	<p class="code">
		<span class="rword">auto</span> <span class="func">function</span>(<span class="rword">int</span> a = <span class="real">5</span>, <span class="auto">int</span> b = <span class="real">5.0</span>){ }
	</p>
	After first argument with a default value, the following arguments must all have a default value.<br />
	<hr />
	<div class="subtopic">
		<h4><a name="varargs">4.3.1 Variable argument list</a></h4>

		It is possible to create a function that accepts an unspecified number of arguments (like using an ellipsis in C++).<br />
		To do so, set the type of the last argument of your function to <span class="rword">auto ref</span>[].<br />
		All excessive arguments will be packed into the <span class="rword">auto ref</span> array, so an <a href="#auterefcast" title="auto ref type explicit cast">explicit cast</a> is needed to convert it to the type you want.<br />
		<div class="example">
			<p class="example_head" id="varargs_ex_1a" onmousedown="toggleView(&quot;varargs_ex_1a&quot;, &quot;varargs_ex_1b&quot, &quot;example of sum of integers using function with variable arguments.&quot;);">Show example of sum of integers using function with variable arguments.</p>
			<p class="code example_body" id="varargs_ex_1b">
<span class="comment">// A function that returns sum of all its arguments. Function expects integers.</span><br />
<span class="rword">int</span> <span class="func">sum</span>(<span class="rword">auto ref</span>[] args)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">int</span> result = <span class="real">0</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// iterate through all arguments and sum them</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">for</span>(i <span class="rword">in</span> <span class="var">args</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">result</span> += <span class="rword">int</span>(<span class="var">i</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">result</span>;<br />
}<br />
<span class="rword">return</span> <span class="func">sum</span>(<span class="real">1</span>, <span class="real">12</span>, <span class="real">201</span>);	<span class="comment">// 214</span><br />
			</p>
		</div>
		Argument type can be found using <span class="func">typeid</span>() function.<br />
		<div class="example">
			<p class="example_head" id="varargs_ex_2a" onmousedown="toggleView(&quot;varargs_ex_2a&quot;, &quot;varargs_ex_2b&quot, &quot;example of println function.&quot;);">Show example of println function.</p>
			<p class="code example_body" id="varargs_ex_2b">
<span class="comment">// Import module that enables output to console.</span><br />
<span class="rword">import</span> <span class="var">std</span>.<span class="var">io</span>;<br />
<span class="comment">// Function returns number of printed arguments</span><br />
<span class="rword">int</span> <span class="func">println</span>(<span class="rword">auto ref</span>[] args)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Assume we are able to print all arguments</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">int</span> printedArgs = <span class="var">args</span>.<span class="var">size</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// iterate through all arguments</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">for</span>(i <span class="rword">in</span> <span class="var">args</span>)<br />
&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// switch by argument type</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">switch</span>(<span class="func">typeid</span>(<span class="var">i</span>))<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">case int</span>:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">io</span>.<span class="var">out</span> << <span class="func">int</span>(<span class="var">i</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">break</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">case double</span>:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">io</span>.<span class="var">out</span> << <span class="func">double</span>(<span class="var">i</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">break</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">case char</span>[]:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">io</span>.<span class="var">out</span> << <span class="rword">char</span>[](<span class="var">i</span>);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">break</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// unknown type, unable to print it, so we decrement printed argument count</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">default</span>:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">printedArgs</span>--;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Add newline</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="var">io</span>.<span class="var">out</span> << <span class="var">io</span>.<span class="var">endl</span>;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Return printed argument count</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="var">printedArgs</span>;<br />
}<br />
<span class="rword">return</span> <span class="func">println</span>(<span class="real">2</span>, " ", <span class="real">4</span>, "<span class="string"> hello </span>", <span class="real">5.0</span>, <span class="real">3.0f</span>);	<span class="comment">// output "2 4 hello 5.0"; 5 is returned</span><br />
			</p>
		</div>
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funclocal">4.3.2 Local functions</a></h4>

		Functions can be defined within other functions.<br />
		Pointers to such functions remain valid after parent function ends.<br />
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funcclosure">4.3.3 Closures</a></h4>

		<div style="background-color: #f00; width: 100%; height: 50px;"></div>
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funcmember">4.3.4 Member functions</a></h4>

		Functions can be defined not only inside class definitions, but also added to a class later.<br />
		The following syntax is used to define class member function outside class definition:<br />
		<p class="code">
			<span class="rword">type</span> <span class="rword">type</span>:<span class="func">function</span>(<span class="comment">/* arguments */</span>){ }
		</p>
		Type before a column must be a direct type name or an alias defined with <span class="rword">typedef</span> expression.<br />
		By using aliases it is possible to add member functions to array, reference and function types.<br />
		Adding member function to array types with explicit size is pointless, because such variables are converted to arrays with implicit size before function call.<br />
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funcinline">4.3.5 Function Literals</a></h4>

		Functions can be written inside expressions, this could be used to define an anonymous function as a function argument, or to return function from function:
		<p class="code">
			<span class="rword">int</span> <span class="func">generateFrom</span>(<span class="rword">int</span> a)<br />
			{<br />
			&nbsp;&nbsp;&nbsp;&nbsp;<span class="rword">return</span> <span class="rword">int</span> <span class="func">gen</span>(){ <span class="rword">return</span> a++; };<br />
			}<br />
		</p>
		Function name can be omitted if function return type is set to auto:
		<p class="code">
			<span class="rword">auto</span> a = <span class="rword">auto</span>(<span class="rword">int</span> b){ <span class="rword">return</span> -b; };<br />
			<span class="rword">int</span> b = <span class="func">a</span>(5); <span class="comment">// b is -5</span><br />
		</p>
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funcoverload">4.3.6 Function overloading</a></h4>

		Functions can be overloaded. Better matching function will be selected during overloaded function call.
	</div>
	<hr />
	<div class="subtopic">
		<h4><a name="funcoperators">4.3.7 Operator overloading</a></h4>

		Operator overloading allows user to define operators that work with any type.<br />
		If operator overloads are placed inside a class or a <a href="#funclocal" title="Local functions">function</a>, they will be visible until the end of a class or the end of a function.<br />
		Following binary operators can be overloaded:<br />
		+ - * / % ** < <= << > >= >> == != & | ^ && || ^^ = += -= *= /= **= []<br />
		For operators = += -= *= /= **= and [], first argument should be a reference to a type, but this is not necessary.<br />
		Following unary operators can be overloaded:<br />
		+ - ~ !<br />
	</div>
</div>
<hr />
<div class="topic">
	<h3><a name="arrunsized">4.4 Arrays with implicit size</a></h3>

	Array with implicit type is defined like this:
	<p class="code">
		<span class="rword">type</span>[] name;
	</p>
	Any array of the same type can be assigned to an array with implicit size.<br />
	<p class="code">
		<span class="rword">int</span>[<span class="real">7</span>] arr1;<br />
		<span class="rword">int</span>[<span class="real">4</span>] arr2;<br />
		<span class="rword">int</span>[] arr1a = arr1;<br />
		arr1a = arr2;
	</p>
	<p class="code">
		<span class="rword">int</span>[<span class="real">7</span>][<span class="real">3</span>] arr1;<br />
		<span class="rword">int</span>[<span class="real">4</span>][<span class="real">3</span>] arr2;<br />
		<span class="rword">int</span>[][<span class="real">3</span>] arr1a = arr1;<br />
		arr1a = arr2;
	</p>
	type[] size is 8 bytes (it consists of pointer to an array and a size field).<br />
	To get array size, use its "size" field:
	<p class="code">
		<span class="rword">int</span> count = arr1a.size;
	</p>
</div>
<hr />
<h2 align="center">5. Special types</h2>
<div class="topic">
	<h3><a name="autoref">5.1 auto ref</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;">
		<br />
		auto ref a = &b;<br />
		int float(auto ref b){ return 5; }<br />
		return int(a) + float(a);";<br />
	</div>
	<div class="subtopic">
		<h4><a name="auterefcast">5.1.1 explicit conversion</a></h4>
		<div style="background-color: #f00; width: 100%; height: 50px;">
		</div>
	</div>
	<div class="subtopic">
		<h4><a name="autorefcall">5.1.2 function call through auto ref</a></h4>
		<div style="background-color: #f00; width: 100%; height: 50px;">
		</div>
	</div>
</div>
<hr />
<div class="topic">
	<h3><a name="typeid">5.2 typeid</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;">
	</div>
</div>
<hr />

<h2 align="center">6. Miscellaneous</h2>
<div class="topic">
	<h3><a name="characters">6.1 Characters</a></h3>

	Characters are eclosed in single quotes ''.<br />
	No more that one character can be inside quotes (after processing <a href="#escapeseq" title="Escape sequences">escape sequences</a>).<br />
</div>
<hr />
<div class="topic">
	<h3><a name="strings">6.2 Strings</a></h3>

	Strings are enclosed in doublequotes "".<br />
	Type of string is array of (length + 1) character.<br />
	Strings are 0-terminated.<br />
</div>
<hr />
<div class="topic">
	<h3><a name="arrayinline">6.3 Inline arrays</a></h3>

	Arrays can be defined by writing all array elements, separated by commas in a { } block.<br />
	Multidimensional array can be also defined by using this.<br />
	<div style="background-color: #f00; width: 100%; height: 50px;">
		For arrays of complex type, all array elements must have the same type.<br />
		It is impossible at the moment, to define array of char, short and float types.<br />
	</div>
</div>
<hr />
<div class="topic">
	<h3><a name="escapeseq">6.4 Escape sequences</a></h3>
	Escape sequences can be used inside character and string expressions.<br />
	Following escape sequences are supported:<br />
	<table border="1px">
		<tr><th>Sequence</th><th>Meaning</th></tr>
		<tr><td>\n</td><td>CR (Carriage return)</td></tr>
		<tr><td>\r</td><td>LF (Line feed)</td></tr>
		<tr><td>\t</td><td>Tab</td></tr>
		<tr><td>\0</td><td>0</td></tr>
		<tr><td>\'</td><td>single quote - '</td></tr>
		<tr><td>\"</td><td>double quote - "</td></tr>
		<tr><td>\\</td><td>backslash - \</td></tr>
	</table>
</div>
<hr />
<div class="topic">
	<h3><a name="binnum">6.5 Binary numbers</a></h3>

	Numbers can be written in binary, and must be followed by letter 'b':<br />
	101b == 5
</div>
<hr />
<div class="topic">
	<h3><a name="octnum">6.6 Octal numbers</a></h3>
	Numbers can be written in base 8, and must start with number 0:<br />
	077 == 63
</div>
<hr />
<div class="topic">
	<h3><a name="hexnum">6.7 Hexadecimal numbers</a></h3>
	Numbers can be written in base 16, and must start with '0x':<br />
	0x80 == 128
</div>
<hr />

<h2 align="center">7. Standard library</h2>
<div class="topic">
	<h3><a name="std_typeinfo">std.typeinfo</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_dynamic">std.dynamic</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_gc">std.gc</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_vector">std.vector</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_list">std.list</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_range">std.range</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_file">std.file</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_io">std.io</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_random">std.random</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />
<div class="topic">
	<h3><a name="std_time">std.time</a></h3>

	<div style="background-color: #f00; width: 100%; height: 50px;"></div>
</div>
<hr />

<h2 align="center">8. Appendix</h2>

<div class="topic">
	<h3><a name="convrules">8.1 Rules applied to value types in a binary operation</a></h3>

	Rule A:<br />
	Operations are made on three types: double, long and int.<br />
	Because of this, different types are converted to these three types:<br />
	<ul>
		<li>char -> int</li>
		<li>short -> int</li>
		<li>float -> double</li>
	</ul>

	Rule B:<br />
	If a binary operation is done on two different types, arguments are converted in a following fashion:<br />
	<ul>
		<li>int * double -> double * double</li>
		<li>long * double -> double * double</li>
		<li>int * long -> long * long</li>
	</ul>
	This is done after applying "Rule A"<br />
	<br />
	Rule C:<br />
	In variable modification expression (+=, -=, *=, /=, **=) binary operation is performed as described in "Rule B",<br />
	And result is converted to type of l-value.<br />
	<p class="code">
		<span class="rword">int</span> a = <span class="real">2</span>;<br />
		a *= <span class="real">2.5</span>; <span class="comment">// a equals 5</span><br />
	</p>
</div>
<hr />
<div class="topic">
	<h3><a name="oppriority">8.2 Operator priority</a></h3>

	<table border="1px">
		<tr><th>#</th><th>Evaluation</th><th>Operation</th></tr>
		<tr><td>1</td><td>left-to-right</td><td>* (unary)</td></tr>
		<tr><td>2</td><td>left-to-right</td><td>. []</td></tr>
		<tr><td>3</td><td>left-to-right</td><td>& (unary) + (unary) - (unary) ~ ! ++ (prefix) -- (prefix)</td></tr>
		<tr><td>4</td><td>left-to-right</td><td>++ (postfix) -- (postfix)</td></tr>
		<tr><td>5</td><td>left-to-right</td><td>**</td></tr>
		<tr><td>6</td><td>left-to-right</td><td>/ * %</td></tr>
		<tr><td>7</td><td>left-to-right</td><td>+ -</td></tr>
		<tr><td>8</td><td>left-to-right</td><td><< >></td></tr>
		<tr><td>9</td><td>left-to-right</td><td>< <= > >=</td></tr>
		<tr><td>10</td><td>left-to-right</td><td>== !=</td></tr>
		<tr><td>11</td><td>left-to-right</td><td>&</td></tr>
		<tr><td>12</td><td>left-to-right</td><td>^</td></tr>
		<tr><td>13</td><td>left-to-right</td><td>|</td></tr>
		<tr><td>14</td><td>left-to-right</td><td>&&</td></tr>
		<tr><td>15</td><td>left-to-right</td><td>^^</td></tr>
		<tr><td>16</td><td>left-to-right</td><td>||</td></tr>
		<tr><td>17</td><td>left-to-right</td><td>?:</td></tr>
		<tr><td>18</td><td>right-to-left</td><td>= += -= *= /= **=</td></tr>
	</table>
</div>
<hr />
<div class="topic">
	<h3><a name="convimplicit">8.3 Implicit conversions</a></h3>

	Apart from implicit conversions from one basic type to the other, there are following conversions between complex types:<br />
	<ul>
		<li>type[size] -> type[]</li>
		<li>type ref -> auto ref</li>
		<li>auto ref -> type ref</li>
	</ul>
</div>
<hr />
	</body>
</html>
