// Complex type test (simple)
float f1;
float2 f2;
float3 f3;
float4 f4;
f1 = 1; // f1 = 1.0
f2.x = 2.0; // f2.x = 2.0
f2.y = 3l; // f2.y = 3.0
f3.x = f2.y; // f3.x = 3.0
f3.y = 4.0f; // f3.y = 4.0
f3.z = f1*f3.x; // f3.z = 3.0
f4.x = f3.y; // f4.x = 4.0
f4.y = 6; // f4.y = 6.0
f4.z = f3.z++; //f4.z = 3.0 f3.z = 4.0
f4.w = 12; // f4.w = 12.0
f3.x += f4.y++; // f3.x = 9.0 f4.y = 7.0
f3.y -= f4.z--; // f3.y = 1.0 f4.z = 2.0
f3.z++; // f3.z = 5.0
++f4.x; // f4.x = 5.0
f4.y--; // f4.y = 6.0
--f4.z; // f4.z = 1.0
f4.w *= f2.x += f3.z = 5; // f3.z = 5.0 f2.x = 7.0 f4.w = 84
f2.x /= 0.5; // f2.x = 14.0
f2.y ^= 2.0; // f2.y = 9.0
// f1 = 1
// f2 = 14; 9
// f3 = 9; 1; 5
// f4 = 5; 6; 1; 84
return 1;

// Complex type test (array)
float3 fa[10];
for(int i = 0; i < 10; i++)
{
	fa[i].x = i*8;
	fa[i].y = fa[i].x++ - i*4;
	fa[fa[(fa[i].x-1)*0.125].y*0.25].z = i+100;
}
// fa[].x = 1   9   17  25  33  41  49  57  65  73
// fa[].y = 0   4   8   12  16  20  24  28  32  36
// fa[].z = 100 101 102 103 104 105 106 107 108 109
return 1;

// Comiler mislead test
float2 a;
a/*[gg]*/.x = 2;
a.y = a/*[gg]*/.x + 3;
// Result:
// a.x = 2; a.y = 5
return a.x;

// Complex type test
float4x4 mat;
mat.row1.y = 5;
return 1;

int a=5;
double d[10];
for(int i = 0; i < a; i++)
d[i] = i*2 + i-2;
return d[5];

double d[10];
return d[5];

float4 f4;
f4.y--;
--f4.z;
return 1;

int test(int x, int y, int z){return x*y+z;}
return 1+test(2, 3, 4);

int fib(int n){ if(n<3) return 1; return fib(n-1)+fib(n-2); }
int test(int x, int y, int z){return x*y+z;}
int b = 1;
if(7>5)
b = 3;
return b+test(2, 3, 4);

int fib(int n){ if(n<3) return 5; return 10; }
return fib(1);

int fib(int n){ if(n<3) return 1; return fib(n-2)+fib(n-1); }
return fib(4);

// Array indirection and optimisation test
int res[5]=1;
res[1] = 13;
res[2] = 3;
res[res[2]] = 4;
res[res[res[2]]] = 12;
return 5;

// Some test ^_^
int a=0;
int b[512];
while(a < 256)
{
  char c[16];
  char ref d = &c[0];
  a = ++a + b[a];
}
return 0;

// Integer tests
int res[30];
int a = 14, b = 3, c = 0;
res[0] = a+b;
res[1] = a-b;
res[2] = -a;
res[3] = ~b;
res[4] = a*b;
res[5] = a/b;
res[6] = a%b;
res[7] = a**b;
res[8] = a > b;
res[9] = a < b;
res[10] = a >= b;
res[11] = a <= b;
res[12] = a == b;
res[13] = a != b;
res[14] = a << b;
res[15] = a >> b;
res[16] = a & b;
res[17] = a | b;
res[18] = a ^ b;
res[19] = a and b;
res[20] = a or b;
res[21] = a xor b;
res[22] = a and c;
res[23] = a or c;
res[24] = a xor c;
res[25] = !a;
res[26] = !c;

return 1;

// Floating point tests
double res[15];
double a = 14.0, b = 3.0;
res[0] = a+b;
res[1] = a-b;
res[2] = -a;
res[3] = a*b;
res[4] = a/b;
res[5] = a%b;
res[6] = a**b;
res[7] = a > b;
res[8] = a < b;
res[9] = a >= b;
res[10] = a <= b;
res[11] = a == b;
res[12] = a != b;
res[13] = !a;

return a+b;

// Long tests
long res[24];
long a = 4494967296l, b = 594967296l, c = 3;
res[0] = a+b; // 5089934592
res[1] = a-b; // 3900000000
res[2] = -a; // -4494967296
res[3] = ~a; // -4494967297
res[4] = a*b; // 2674358537709551616
res[5] = a/b; // 7
res[6] = a%b; // 330196224
res[7] = 59496729**c; // 3659347023269828617
res[8] = a > b; // 1
res[9] = a < b; // 0
res[10] = a >= b; // 1
res[11] = a <= b; // 0
res[12] = a == b; // 0
res[13] = a != b; // 1
res[14] = a << c; // 35959738368 
res[15] = c << 45; // 105553116266496 
res[16] = a >> c; // 561870912
res[17] = a & b; // 56771072
res[18] = a | b; // 5033163520
res[19] = a ^ b; // 4976392448
res[20] = a and b; // 1
res[21] = a or b; // 1
res[22] = a xor b; // 0
res[23] = !a; // 0

return 1;

// Decrement and increment tests for all types
double a1=5, b1=5;
float a2=5, b2=5;
long a3=5, b3=5;
int a4=5, b4=5;
short a5=5, b5=5;
char a6=5, b6=5;
a1++;
b1--;
a2++;
b2--;
a3++;
b3--;
a4++;
b4--;
a5++;
b5--;
a6++;
b6--;
return 1;

// Old all-in-one test
double test(float x, float y){ /*teste*/return x**2*y; }
int a=5;
float b, c[3]=14**2-134;
double d[10];
for(int i = 0; i< 10; i++)
d[i] = test(i*2, i-2);
double n=1;
while(1){ n*=2; if(n>1000) break; }
return 2+test(2, 3)+a**b;


//longPow speed test (2 sec on x86)
long a = 43l, b = 10l; // 2 sec
//long a = 1l, b = 1250l; // 100 ms
//long a = 0l, b = 1250l; // 100 ms
//long a = 48l, b = 1250l; // 110 ms
//long a = 45486127846l, b = 10l; // 2 sec
//long a = 2l, b = 63l; // 3 sec
long c;
for(int i = 0; i < 10000000; i++)
  c = a**b;
return c;

// Division by zero handling
int a=5, b =0;
return a/b;

// Type conversions
int ia=3, ib, ic;
double da=5.0, db, dc;
long la=4l, lb, lc;
ib = da;
ic = la;
db = ia;
dc = la;
lb = ia;
lc = da;
return 1;

int a[10]=5;
return 1;

// Build-In function checks
double res[20];
res[0] = cos(0); // 1.0
res[1] = cos(60); // 0.5
res[2] = cos(180); // -1.0

res[3] = sin(0); // 0.0
res[4] = sin(30); // 0.5
res[5] = sin(180); // 0.0

res[6] = ceil(1.5); // 2.0
res[7] = floor(1.5); // 1.0
res[8] = ceil(-1.5); // -1.0
res[9] = floor(-1.5); // -2.0

res[10] = tan(0); // 0.0
res[11] = tan(45); // 1.0
res[12] = tan(90); // +inf

res[13] = ctg(0); // +inf
res[14] = ctg(45); // 1.0
res[15] = ctg(90); // 0.0

res[16] = sqrt(1.0); // 1.0
res[17] = sqrt(0.0); // 0.0
res[18] = sqrt(9.0); // 3.0

res[19] = clock();
return clock();


double a = 0.9;
return a**2.0;


double clamp(double a, double min, double max)
{
  if(a < min)
    return min;
  if(a > max)
    return max;
  return a;
}
double abs(double x)
{
  if(x < 0.0)
    return -x;
  return x;
}
return clamp(abs(-1.5), 0.0, 1.0);

int test(int x, int y, int z){return x*y+z;}
int res;
{
int x = 2;
{
res = 1+test(x, 3, 4);
}
}
return res;

double abs(double x)
{
  {
    if(x < 0.0)
      return -x;
  }
  return x;
}
return abs(-0.5);

//Some complexness %)
float3 a;
float4 b;
a = 12.0; // should fail
b = a; // should fail
return 1;

int test[5]=0;
for(int i = 0; i < 5; i++)
{
  test[i] = 1;
  test[i] += 5;
  test[i] = test[i]++;
  test[i] = ++test[i];
}
return 1;

int test[2]=0;
for(int i = 0; i < 2; i++)
  test[i] = test[i]++;
return 1;

// Pointers!
int testA(int ref v){ return *v * 5; }
void testB(int ref v){ *v += 5; }
int a = 5;
int ref b = &a;
int c = 2;
c = *b;
*b = 14;
*b++;
*b *= 4;
testB(b);
return testA(&a);

// Pointers on complex!
double length(float4 ref v)
{
	return sqrt((v.x*v.x)+(v.y*v.y)+(v.z*v.z));
}
void normalize(float4 ref v)
{
	double len = length(v);
	v.x /= len; v.y /= len; v.z /= len;
}
float4 a;
a.x = 12.0;
a.y = 4.0;
a.z = 3.0;
a.w = 1.0;
float4 ref b = &a;
normalize(&a);
return length(b);

float4 a;
float4 ref b = &a;
b.x = 5.0f;
return b.x;

double testA(float4 ref v){ return v.x; }
float4 a;
float4 ref b = &a;
a.x = 5.0f;
return testA(b);

float3 a;
float x = a.x, y = a.y;
return 1;

int a = 12;
int res[6];
res[0] = a + 0;
res[1] = a * 0;
res[2] = a * 1;
res[3] = (a*1) +(a*0);
res[4] = a*2+0;
res[5] = a*3*1;
return 1;

int arr[5];
float4 arrF[4];
int ref a = &arr[3];
*a = 55;
float4 ref b = &arrF[1];
b.x = 85;
float ref c = &arrF[1].y;
*c = 125;
{
	int ref a = &arr[1];
	*a = 5;
	float4 ref b = &arrF[2];
	b.x = 8;
	float ref c = &arrF[2].y;
	*c = 12;
}
return 1;

int calltest = 0;
int fib(int n, int ref calls)
{
	*calls++;
	calltest++;
	if(n < 3)
		return 1;
	return fib(n-2, calls) + fib(n-1, calls);
}
int calls = 0;
return fib(40, &calls);


double neg(double a){ return -a; }
double x = 5.0, nx;
for(var int i = 0; i < 50000000; i++)
nx = neg(x);
return nx;


int fa(int i){ return i*2; }
int fa(int i, double c){ return i*c; }
int fa(float i){ return i*3.0f; }
return fa(5.0f) * fa(2, 3.0);

// Function with no return handling
int test(){ 1; }
return test();

// Array out of bound check (negative)
int arr[10] = 5;
int badID1 = cos(125)*4;
arr[badID1] = 4;
return badID1;

// Array out of bound check (overflow)
int arr[10] = 5;
int badID1 = sqrt(256);
arr[badID1] = 4;
return badID1;

// Switch test!
int u = 12;
int a = 3, b = 0;
{
  switch(a)
  {
    case 1:
  	  b = 5;
	  break;
    case 3:
	  b = 7;
	  break;
	case 5:
	  b = 18;
  }
}
return u;

// Class test
class One
{
  int a, b, c;
  float e, f;
}
class Two
{
  One a, b;
  float3 c;
  int d;
}
One one;
Two two;
one.a = 3;
one.e = 2;
two.a.a = 14;
two.c.x = 2;
return 1;

// Variable modify test
int slow(int how){ for(int i = 0; i < how; i++){ how = how-1; } return 2; }
int index = 2;
int arr[10] = 4;
arr[slow(40000000)] += 16; // 330 ms total. target - 140ms
return 3;

// Class test 2
class One
{
  int a, b, c;
  float e, f;
}
class Two
{
  One a, b;
  float3 c;
  int d;
}
Two two, twonext;
float3[2] fa[4];
int[2] ia[4];
double da[8];
char c = 66;
short u = 15;
long l = 45645l;
l *= 4594454795l;
float4x4 mat;

two.a.a = 14;
two.c.x = 2;
two.d = 5;
twonext = two;
return 1;

int test(int a){ return a*2; }
return test(5);

//Complex types test #3
float test(float4 a, float4 b){ return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w; }
float4 test2(float4 u){ u.x += 5.0; return u; }
float4 float4(float x, float y, float z, float w){ float4 ret; ret.x = x; ret.y = y; ret.z = z; ret.w = w; return ret; }
float4 float4(float all){ float4 ret; ret.x = ret.y = ret.z = ret.w = all; return ret; }
float4 float4(float3 xyz, float w){ float4 ret; ret.x = xyz.x; ret.y = xyz.y; ret.z = xyz.z; ret.w = w; return ret; }
float sum(float[10] u){ float res = 0; for(int i = 0; i < 10; i++) res += u[i]; return res; }
float[10] inc(float[10] v){ float[10] res; for(int i = 0; i < 10; i++) res[i] = v[i]+1.0f; return res; }
float4 n, m;
n.x = 6.0f;
n.y = 3.0f;
n.z = 5.0f;
n.w = 0.0f;

m.x = 2.0f;
m.y = 3.0f;
m.z = 7.0f;
m.w = 0.0f;
float3 k;
k.x = 12.0;
k.y = 4.7;
k.z = 0;
float4 u = test2(n), v = float4(2.5, 1.2, 5, 6.0), w = float4(5.9), q = float4(k, 2.0);
float[10] arr;
for(int i = 0; i < 10; i++)
  arr[i] = i*1.5f;
float arrSum = sum(arr);
float[10] iArr = inc(arr);
float iArrSum = sum(iArr);
// n={6.0  3.0 5.0 0.0}
// m={2.0  3.0 7.0 0.0}
// k={12.0 4.7 0.0}
// u={11.0 3.0 5.0 0.0}
// v={2.5  1.2 5.0 6.0}
// w={5.9  5.9 5.9 5.9}
// q={12.0 4.7 0.0 2.0}
// arr={0.0 1.5 3.0 4.5 6.0 7.5 9.0 10.5 12.0 13.5}
// arrSum=67.5
// iArr={1.0 2.5 4.0 5.5 7.0 8.5 10.0 11.5 13.0 14.5}
// iArrSum=77.5
return test(n, m); // 56.0

// Speed tests
float4x4 mat;
class Float{ float x; }
Float f;
float2 f2;
float3 f3;
float4 f4;
float4x4 test(float4x4 p){ p.row1.y *= 2.0f; return p; }
Float test(Float p){ p.x *= 2.0f; return p; }
float2 test(float2 p){ p.y *= 2.0f; return p; }
float3 test(float3 p){ p.y *= 2.0f; return p; }
float4 test(float4 p){ p.y *= 2.0f; return p; }
for(int i = 0; i < 10000000; i++)
{
  mat = test(mat);
  f = test(f);
  f2 = test(f2);
  f3 = test(f3);
  f4 = test(f4);
}
return mat.row1.y;

//Auto type tests
float lengthSqr(float3 ref f){ return f.x*f.x+f.y*f.y+f.z*f.z; }
float[10] tenArr(float n){ float[10] arr; for(int i = 0; i < 10; i++) arr[i] = n; return arr; }
auto b = 15;
auto c = 2*2.0;
float3 m;
m.x = 3.0;
m.z = 1;
auto n = m, nd = lengthSqr(&n);
auto k = c = 12;
auto ar = tenArr(3.0);

// erroneous
//auto er = pi, err;
//auto inf(){ return 5; }
//auto ref er2 = &b;
//auto er3[10] = 12;
//class Errored{ auto b; }

auto u = &b;
return *u;