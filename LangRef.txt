
//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Базовые типы

void	| 0 байт	| только как тип возврата функции (ничего не возвращает)

char	| 1 байт	| значения: 0..255
short	| 2 байта	| значения: -32768..32767
int		| 4 байта	| значения: -2147483648..2147483647
long	| 8 байт	| значения: -9223372036854775808..9223372036854775807
float	| 4 байта	| значения: IEEE	| Выравнивается на границу в 4 байта (О выравнивании ниже)
double	| 8 байт	| значения: IEEE	| Выравнивается на границу в 8 байт

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Определение пользовательских типов

[noalign или align(bytes)] class name
{
	type1 name1, name2, ...;
	type2 name3, name4, ...;
	...
}
Выравнивание по умолчанию отсутствует (noalign). Размер типа будет расширен, чтобы стать кратным 4 байтам.
Выравнивание не может превышать 16 байт.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Выравнивание переменных
	
Установленное по умолчанию выравнивание типа можно изменить, используя следующие конструкции:
noalign type name; // переменная name типа type не будет выравниваться
align(bytes) type name; // переменная name типа type будет выровнена на границу в bytes байтов
bytes не может превышать 16 байт.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Определение переменных

Элементы в фигурных скобках не обязательны.

{noalign или align(bytes) или ничего} type {[size] или ref}{[size] или ref}{и т.д.} name {= value} ;
Все переменные будут иметь одинаковый тип, и каждая переменная будет выровнена, как указано.

Если одномерный массив определяется значением - элементом этого массива, это значение будет присвоено всем элементам массива:
int[256*256] image = RGBA(128, 96, 0, 255);

Стоит рассказать о многомерных массивах:

int[7][3] arr;
Определяет массив из семи элементов типа int[3].

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Автоматические типы
	
При определении переменной, вместо имени типа можно использовать идентификатор auto.
В таком случае, тип переменной будет выведен автоматически, но для этого значение переменной должно быть определено в  месте определения переменной.
Примеры:
auto i = 5; // i имеет тип int
auto n = &i; // n имеет тип int ref
int[10] arr;
auto copy = arr; // copy имеет тип int[10]

Выравнивание с автоматическими типами работает так же, как и с обычными.

auto может использоваться в качестве типа возвращаемого значения функции.
Если такая функция имеет несколько точек возврата, и типы возвращаемых значений не совпадают, будет выдана ошибка.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Оператор typeof

typeof(expression) позволяет указать тип, который является результатом указанного в скобках выражения

typeof(4) == int
typeof(4 * 0.2) == double

typeof следует использовать для получения типов функций в случаях, когда тип auto не доступен (например, в определении параметров функции)

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Оператор sizeof
	
sizeof(expression) позволяет узнать размер типа, который является результатом указанного в скобках выражения

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Массивы с нестрогим размером
	
Имеется возможность определить переменную такого типа, что к ней будет возможно присвоить массив любого размера, имеющий такой же
тип элемента.
Примеры:
int[7] arr1;
int[4] arr2;
int[] arr1a = arr1;
arr1a = arr2;

int[7][3] arr1;
int[4][3] arr2;
int[][3] arr1a = arr1;
arr1a = arr2;

Такой тип имеет размер 8 байт. Он представляется как указатель на массив (тоесть по нему можно менять значения оригинала, это не копия!)
Для получения количества элементов такого массива, используйте поле size:
int count = arr1a.size;

Основное применение таких переменных - передача массивов в функции, как, например, в следующем примере:
int Sum(int[] arr){ int res=0; for(int i = 0; i < arr.size; i++) res += arr[i]; return res; }
int[7] arr;
int[4] arr2;
...
auto sum = Sum(arr), sum2 = Sum(arr2);

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Пользовательские функции
	
type name(type1 param1, type2 param2, ...){ /* code */ }

Определение функции указывает возвращаемое значение и список передаваемых параметров.
Функции можно перегружать, не смотря на свободное приведение базовых численных типов друг к другу, если
имеется несколько вариантов функций с параметром базового типа, будет выбрано наилучшее совпадение.
Если функция не возвратит значение с помощью оператора return, и возвращаемый тип не равен void, исполнение программы
прекратиться в течение вызова такой функции.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Правила действующие при операциях с переменными.

Правило А:
Виртуальная машина непосредственно работает только с тремя типами переменных: double, long и int
По этой причине, перед выполнением операций, тип расширяется до наиболее подходящего:
	char -> int
	short -> int
	float -> double

Правило Б:
Если в бинарной операции участвует два различных типа, то один из них будет преобразован по следующей схеме:
int * double -> double * double			double * int -> double * double
long * double -> double * double		double * long -> double * double
int * long -> long * long				long * int -> long * long
С остальными типами действия производятся после принятия "Правила А"

Правило В:
При использовании присвоения с операцией (a += b, и т.д.) операция производиться как описано в "Правиле Б"
Затем результат приводиться к типу переменной a, после чего возможно присвоение нового значения переменной.
	Пример: int a = 2; a *= 2.5; // a равно 5

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Приоритет операций
	Evaluation		Operation
1	left-to-right	* (unary)
2	left-to-right	. []
3	left-to-right	& (unary) + (unary) - (unary) ~ ! ++ (prefix) -- (prefix)
4	left-to-right	++ (postfix) -- (postfix)
5	left-to-right	**
6	left-to-right	/ * %
7	left-to-right	+ -
8	left-to-right	<< >>
9	left-to-right	< <= > >=
10	left-to-right	== !=
11	left-to-right	&
12	left-to-right	^
13	left-to-right	|
14	left-to-right	&&
15	left-to-right	^^
16	left-to-right	||
17	left-to-right	?:
18	right-to-left	= += -= *= /= **=

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Неявные преобразования

Кроме неявных преобразований между встроенными числовыми типами, имеются следующие преобразования между производными типами:
	type[size] -> type[]
	type ref -> auto ref
	auto ref -> type ref

