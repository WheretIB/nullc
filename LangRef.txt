
//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Базовые типы

void	| 0 байт	| только как тип возврата функции (ничего не возвращает)

char	| 1 байт	| значения: 0..255
short	| 2 байта	| значения: -32768..32767
int		| 4 байта	| значения: -2147483648..2147483647
long	| 8 байт	| значения: -9223372036854775808..9223372036854775807
float	| 4 байта	| значения: IEEE	| Выравнивается на границу в 4 байта (О выравнивании ниже)
double	| 8 байт	| значения: IEEE	| Выравнивается на границу в 8 байт

file	| 4 байта	| идентификатор файла

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Встроенные составные типы
											
float2	| align(4) class float2{ float x, y; }
float3	| align(4) class float3{ float x, y, z; }
float4	| align(4) class float4{ float x, y, z, w; }
double2	| align(8) class double2{ double x, y; }
double3	| align(8) class double3{ double x, y, z; }
double4	| align(8) class double4{ double x, y, z, w; }

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Определение пользовательских типов

{noalign или align(bytes)} class name
{
	type1 name1, name2, ...;
	type2 name3, name4, ...;
	...
}
Выравнивание по умолчанию отсутствует (noalign). Размер типа будет расширен, чтобы стать кратным 4 байтам.
Выравнивание не может превышать 16 байт.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Выравнивание переменных
	
Установленное по умолчанию выравнивание типа можно изменить, используя следующие конструкции:
noalign type name; // переменная name типа type не будет выравниваться
align(bytes) type name; // переменная name типа type будет выровнена на границу в bytes байтов
bytes не может превышать 16 байт.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Определение переменных

Элементы в фигурных скобках не обязательны.

{noalign или align(bytes) или ничего} type {[size] или ref}{[size] или ref}{и т.д.} name {[size]} {= value} ;
Все переменные будут иметь одинаковый тип, и каждая переменная будет выровнена, как указано.

Если одномерный массив определяется значением - элементом этого массива, это значение будет присвоено всем элементам массива:
int image[256*256] = RGBA(128, 96, 0, 255);

Стоит рассказать о многомерных массивах:

int[7][3] arr;
определяет массив из семи элементов типа int[3].
но
int[7] arr[3];
определяет массив из трёх элементов типа int[7].

Также следует отметить, что при написании
int[7] arr[3], arr2;
переменная arr2 будет иметь такой же тип, как и arr!

Для ясности, указывать размер массива всегда следует до имени переменной.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Автоматические типы
	
При определении переменной, вместо имени типа можно использовать идентификатор auto.
В таком случае, тип переменной будет выведен автоматически, но для этого значение переменной должно быть определено в  месте определения переменной.
Примеры:
auto i = 5; // i имеет тип int
auto n = &i; // n имеет тип int ref
int[10] arr;
auto copy = arr; // copy имеет тип int[10]

Выравнивание с автоматическими типами работает так же, как и с обычными.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Массивы с нестрогим размером
	
Имеется возможность определить переменную такого типа, что к ней будет возможно присвоить массив любого размера, имеющий такой же
тип элемента.
Примеры:
int[7] arr1;
int[4] arr2;
int[] arr1a = arr1;
arr1a = arr2;

int[7][3] arr1;
int[4][3] arr2;
int[][3] arr1a = arr1;
arr1a = arr2;

Такой тип имеет размер 8 байт. Он представляется как указатель на массив (тоесть по нему можно менять значения оригинала, это не копия!)
Для получения количества элементов такого массива, используйте поле size:
int count = arr1a.size;

Основное применение таких переменных - передача массивов в функции, как, например, в следующем примере:
int Sum(int[] arr){ int res=0; for(int i = 0; i < arr.size; i++) res += arr[i]; return res; }
int[7] arr; int[4] arr2;
...
auto sum = Sum(arr), sum2 = Sum(arr2);

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Пользовательские функции
	
type name(type1 param1, type2 param2, ...){ /* code */ }

Определение функции указывает возвращаемое значение и список передаваемых параметров.
Функции можно перегружать, не смотря на свободное приведение базовых численных типов друг к другу, если
имеется несколько вариантов функций с параметром базового типа, будет выбрано наилучшее совпадение.
Если функция не возвратит значение с помощью оператора return, и возвращаемый тип не равен void, исполнение программы
прекратиться в течение вызова такой функции.

//////////////////////////////////////////////////////////////////////////////////////////////////////////
	Правила действующие при операциях с переменными.

Правило А:
Виртуальная машина непосредственно работает только с тремя типами переменных: double, long и int
По этой причине, перед выполнением операций, тип расширяется до наиболее подходящего:
	char -> int
	short -> int
	float -> double

Правило Б:
Если в бинарной операции участвует два различных типа, то один из них будет преобразован по следующей схеме:
int * double -> double * double			double * int -> double * double
long * double -> double * double		double * long -> double * double
int * long -> long * long				long * int -> long * long
С остальными типами действия производятся после принятия "Правила А"

Правило В:
При использовании присвоения с операцией (a += b, и т.д.) операция производиться как описано в "Правиле Б"
Затем результат приводиться к типу переменной a, после чего возможно присвоение нового значения переменной.
	Пример: int a = 2; a *= 2.5; // a равно 5



